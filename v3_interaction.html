<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPHILINI | Atomic v6.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: 'Inter', sans-serif; color: #f8fafc; }
        .side-panel { background: #ffffff; border-right: 1px solid #1e293b; z-index: 50; color: #0f172a; }
        #tooltip { position: absolute; pointer-events: none; display: none; background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(4px); color: white; padding: 12px; border-radius: 8px; font-size: 11px; z-index: 1000; border: 1px solid #334155; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .num-input { background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; padding: 2px 4px; font-weight: 800; width: 60px; text-align: center; }
        /* Анімація завантаження */
        #loader { position: fixed; inset: 0; background: #020617; z-index: 9999; display: flex; align-items: center; justify-content: center; transition: opacity 0.5s; pointer-events: none; }
    </style>
</head>
<body class="flex">

    <div id="loader"><div class="text-blue-500 font-mono font-bold animate-pulse">GENERATING TIME PARTICLES...</div></div>
    <div id="tooltip"></div>

    <aside class="side-panel w-72 h-screen flex flex-col shadow-2xl relative">
        <div class="p-6 bg-slate-50 border-b border-slate-200">
            <h1 class="text-xl font-black italic tracking-tighter uppercase">IPHILINI<br><span class="text-blue-600 text-[9px] not-italic tracking-[0.3em]">ATOMIC v6.0</span></h1>
            <p id="live-clock" class="text-[11px] font-mono text-slate-500 font-bold mt-4 p-2 bg-white border border-slate-200 rounded-lg text-center uppercase shadow-sm"></p>
        </div>

        <div class="px-6 py-4 space-y-3 bg-white">
            <div class="flex items-center justify-between text-[10px] font-black text-slate-400 uppercase tracking-widest">
                <span>Масштаб %</span>
                <input id="in-height-pct" type="number" value="180" class="num-input">
            </div>
            <div class="flex items-center justify-between text-[10px] font-black text-slate-400 uppercase tracking-widest">
                <span>Днів</span>
                <input id="in-days" type="number" value="30" class="num-input">
            </div>
            <div class="flex items-center justify-between text-[10px] font-black text-slate-400 uppercase tracking-widest">
                <span>Деталізація (сек)</span>
                <input id="in-res" type="number" value="60" min="1" step="1" class="num-input text-blue-600">
            </div>
        </div>

        <div class="flex-1 overflow-y-auto px-6 pb-10 border-t border-slate-100 bg-slate-50/50">
             <h3 class="text-[9px] font-black text-slate-300 uppercase tracking-widest my-4 italic text-center">— Активні події —</h3>
            <div id="sidebar-event-list" class="space-y-2"></div>
        </div>
    </aside>

    <div id="event-modal" class="fixed inset-y-0 left-72 w-80 bg-white z-[2000] shadow-2xl transform -translate-x-full transition-transform duration-300 hidden flex-col p-8 border-r text-slate-900">
        <h2 class="text-lg font-black uppercase italic mb-8">Частка часу</h2>
        <div class="space-y-5 flex-1">
            <input id="ev-summary" type="text" placeholder="Назва події" class="w-full p-4 bg-slate-50 rounded-xl font-bold border-none outline-none focus:ring-2 ring-blue-500" />
            <div class="space-y-1">
                <label class="text-[9px] font-black text-slate-400 uppercase">Початок</label>
                <input id="ev-start" type="datetime-local" class="w-full p-3 bg-slate-50 rounded-xl font-bold text-sm" />
            </div>
            <div class="space-y-1">
                <label class="text-[9px] font-black text-slate-400 uppercase">Кінець</label>
                <input id="ev-end" type="datetime-local" class="w-full p-3 bg-slate-50 rounded-xl font-bold text-sm" />
            </div>
            <select id="ev-repeat" class="w-full p-3 bg-slate-50 rounded-xl font-bold text-sm">
                <option value="none">Без повторів</option>
                <option value="daily">Щодня</option>
            </select>
            <input id="ev-color" type="color" value="#3b82f6" class="w-full h-10 rounded-lg cursor-pointer bg-transparent border-none" />
        </div>
        <div class="pt-8 space-y-2">
            <button onclick="window.saveEvent()" class="w-full py-4 bg-blue-600 text-white rounded-2xl font-black uppercase text-xs shadow-lg hover:bg-blue-700 transition-all">Заповнити цей час</button>
            <button onclick="window.deleteEvent()" id="btn-delete" class="w-full py-2 text-red-500 font-bold uppercase text-[9px]">Очистити час</button>
            <button onclick="window.closeModal()" class="w-full py-2 text-slate-400 font-bold uppercase text-[9px]">Назад</button>
        </div>
    </div>

    <main id="canvas-container" class="flex-1 relative bg-slate-950 cursor-crosshair"></main>

    <script>
        // CONFIG
        const START_ANGLE = -Math.PI / 2; 
        let CONFIG = { 
            radius: 8, 
            heightPct: 180, 
            renderDays: 30, 
            baseDate: new Date().setHours(0,0,0,0),
            resolution: 60 // 1 точка = 60 секунд (змініть на 1 для хардкору)
        };
        let events = JSON.parse(localStorage.getItem('iphilini_v60_data')) || [];
        let editingId = null;

        const getDayHeight = () => (CONFIG.radius * (CONFIG.heightPct / 100));

        // THREE JS INIT
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020617, 0.015); // Атмосферний туман
        
        const container = document.getElementById('canvas-container');
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); // false for performance
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1.5 : 1); // Opt for perf
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(25, 30, 25);
        controls.enableDamping = true;

        // SYSTEMS
        let particlesGeometry = null;
        let particlesMaterial = null;
        let particlesSystem = null;
        let markersSystem = null;
        const nowMarker = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x60a5fa })
        );
        scene.add(nowMarker);

        // --- ATOMIC MATH ---
        function getPointForTime(secondsFromBase) {
            const hrs = secondsFromBase / 3600;
            const angle = (hrs / 24) * Math.PI * 2 + START_ANGLE;
            const y = (hrs / 24) * getDayHeight();
            return {
                x: Math.cos(angle) * CONFIG.radius,
                y: y,
                z: Math.sin(angle) * CONFIG.radius
            };
        }

        function generateParticles() {
            if (particlesSystem) { scene.remove(particlesSystem); particlesGeometry.dispose(); }
            if (markersSystem) { scene.remove(markersSystem); }

            const totalSeconds = CONFIG.renderDays * 24 * 3600;
            const count = Math.floor(totalSeconds / CONFIG.resolution);
            
            particlesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);

            // Основні частки часу
            for (let i = 0; i < count; i++) {
                const s = i * CONFIG.resolution;
                const p = getPointForTime(s);
                
                positions[i*3] = p.x;
                positions[i*3+1] = p.y;
                positions[i*3+2] = p.z;

                // Базовий колір (темно-сірий)
                colors[i*3] = 0.2; // R
                colors[i*3+1] = 0.25; // G
                colors[i*3+2] = 0.35; // B
                
                sizes[i] = 1.0;
            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            // Note: size attribute requires custom shader or PointsMaterial sizeAttenuation which is global.
            // We'll use color to distinguish for now.

            particlesMaterial = new THREE.PointsMaterial({ 
                size: 0.15, 
                vertexColors: true, 
                sizeAttenuation: true,
                map: createDotTexture(),
                alphaTest: 0.5,
                transparent: true
            });

            particlesSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesSystem);

            // МАРКЕРИ (Окремий систем для більших точок)
            generateMarkers();
            
            // Застосувати події (пофарбувати)
            paintEvents();

            document.getElementById('loader').style.opacity = 0;
            setTimeout(()=>document.getElementById('loader').style.display='none', 500);
        }

        function generateMarkers() {
            const markerGeo = new THREE.BufferGeometry();
            const mPos = [];
            const mCol = [];
            
            // Кожна година
            for (let h = 0; h <= CONFIG.renderDays * 24; h++) {
                const p = getPointForTime(h * 3600);
                mPos.push(p.x, p.y, p.z);
                
                if (h % 24 === 0) { // Новий день
                    mCol.push(0.2, 0.4, 1.0); // Blue
                } else {
                    mCol.push(0.3, 0.3, 0.3); // Dim Grey
                }
            }
            markerGeo.setAttribute('position', new THREE.Float32BufferAttribute(mPos, 3));
            markerGeo.setAttribute('color', new THREE.Float32BufferAttribute(mCol, 3));
            
            markersSystem = new THREE.Points(markerGeo, new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                map: createDotTexture(),
                alphaTest: 0.5
            }));
            scene.add(markersSystem);
        }

        function paintEvents() {
            const colors = particlesSystem.geometry.attributes.color;
            const count = colors.count;

            // Reset colors
            for (let i = 0; i < count; i++) {
                // Відновлення "темного" фону
                const isHour = (i * CONFIG.resolution) % 3600 < CONFIG.resolution;
                if(isHour) { colors.setXYZ(i, 0.3, 0.3, 0.4); } 
                else { colors.setXYZ(i, 0.12, 0.15, 0.22); }
            }

            // Paint Events
            events.forEach(ev => {
                const col = new THREE.Color(ev.color);
                
                // Helper to paint range
                const paintRange = (startMs, endMs) => {
                    const startIdx = Math.floor((startMs - CONFIG.baseDate) / 1000 / CONFIG.resolution);
                    const endIdx = Math.floor((endMs - CONFIG.baseDate) / 1000 / CONFIG.resolution);
                    
                    for (let i = startIdx; i < endIdx; i++) {
                        if (i >= 0 && i < count) {
                            colors.setXYZ(i, col.r, col.g, col.b);
                        }
                    }
                };

                const start = new Date(ev.start);
                const end = new Date(ev.end);
                
                if (ev.repeat === 'daily') {
                    for(let d=0; d<CONFIG.renderDays; d++) {
                        const s = new Date(start.getTime() + d*86400000);
                        const e = new Date(end.getTime() + d*86400000);
                        paintRange(s.getTime(), e.getTime());
                    }
                } else {
                    paintRange(start.getTime(), end.getTime());
                }
            });

            colors.needsUpdate = true;
            updateSidebar();
        }

        function createDotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // INTERACTION
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.5; // Чутливість "магніту"
        const mouse = new THREE.Vector2();

        container.addEventListener('pointermove', (e) => {
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / container.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // Перевіряємо тільки основну хмару (вона містить всю інформацію)
            const hits = raycaster.intersectObject(particlesSystem);
            const t = document.getElementById('tooltip');

            if (hits.length > 0) {
                const index = hits[0].index;
                // Час = базовий + індекс * роздільну здатність
                const timeMs = CONFIG.baseDate + index * CONFIG.resolution * 1000;
                const date = new Date(timeMs);
                
                // Перевірка, чи це подія (за кольором)
                const colAttr = particlesSystem.geometry.attributes.color;
                const r = colAttr.getX(index);
                // Простий чек: якщо колір яскравий (>0.4), це ймовірно подія
                const isEvent = r > 0.4 || colAttr.getY(index) > 0.4; // Груба евристика, але працює візуально

                t.style.display = 'block'; t.style.left = e.clientX + 15 + 'px'; t.style.top = e.clientY + 'px';
                
                // Знайти подію, якщо це подія
                let foundEvent = null;
                if(isEvent) {
                    // Це повільніше, але точно. Для продакшену можна використовувати хеш-мапу індексів.
                    // Для прототипу перебираємо події.
                    // Враховуємо повторення
                     // ... спрощено для демо:
                     t.innerHTML = `<div class="text-[10px] text-slate-400">ЧАС</div><div class="font-mono font-bold text-lg">${date.toLocaleTimeString('uk',{hour:'2-digit',minute:'2-digit'})}</div><div class="text-[10px] text-slate-500">${date.toLocaleDateString('uk')}</div>`;
                } else {
                    t.innerHTML = `<div class="font-mono font-bold text-blue-300">${date.toLocaleTimeString('uk',{hour:'2-digit',minute:'2-digit'})}</div>`;
                }
                
                // Highlight cursor pos
                document.body.style.cursor = 'crosshair';
            } else {
                t.style.display = 'none'; document.body.style.cursor = 'default';
            }
        });

        container.addEventListener('pointerup', (e) => {
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(particlesSystem);
            if(hits.length > 0) {
                const index = hits[0].index;
                const timeMs = CONFIG.baseDate + index * CONFIG.resolution * 1000;
                const date = new Date(timeMs);
                
                // Тут логіка пошуку події для редагування
                // Для демо просто відкриваємо нову на цьому місці
                window.openModal({ id: null, summary: "", start: date, end: new Date(date.getTime() + 3600000), color: "#3b82f6", repeat: 'none' });
            }
        });

        // UI & LOGIC
        window.openModal = (ev) => {
            editingId = ev.id;
            document.getElementById('ev-summary').value = ev.summary;
            document.getElementById('ev-color').value = ev.color;
            const toISO = (d) => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().slice(0,16);
            document.getElementById('ev-start').value = toISO(new Date(ev.start));
            document.getElementById('ev-end').value = toISO(new Date(ev.end));
            const modal = document.getElementById('event-modal');
            modal.style.display = 'flex'; setTimeout(() => modal.style.transform = 'translateX(0)', 10);
        };

        window.saveEvent = () => {
            const data = {
                id: editingId || Date.now(),
                summary: document.getElementById('ev-summary').value || "Частка часу",
                start: new Date(document.getElementById('ev-start').value).getTime(),
                end: new Date(document.getElementById('ev-end').value).getTime(),
                repeat: document.getElementById('ev-repeat').value,
                color: document.getElementById('ev-color').value
            };
            if(editingId) events = events.map(e => e.id === editingId ? data : e);
            else events.push(data);
            localStorage.setItem('iphilini_v60_data', JSON.stringify(events));
            paintEvents(); window.closeModal();
        };

        window.closeModal = () => {
            const modal = document.getElementById('event-modal');
            modal.style.transform = 'translateX(-100%)'; setTimeout(() => modal.style.display = 'none', 300);
        };
        
        window.deleteEvent = () => { events = events.filter(e => e.id !== editingId); localStorage.setItem('iphilini_v60_data', JSON.stringify(events)); paintEvents(); window.closeModal(); };

        function updateSidebar() {
            const l = document.getElementById('sidebar-event-list'); l.innerHTML = '';
            events.forEach(ev => {
                const el = document.createElement('div');
                el.className = 'p-3 bg-white rounded-lg border-l-4 text-xs shadow-sm cursor-pointer hover:shadow-md';
                el.style.borderLeftColor = ev.color;
                el.innerHTML = `<b>${ev.summary}</b>`;
                el.onclick = () => window.openModal(ev);
                l.appendChild(el);
            });
        }

        // Inputs
        document.getElementById('in-height-pct').onchange = (e) => { CONFIG.heightPct = parseInt(e.target.value); generateParticles(); };
        document.getElementById('in-days').onchange = (e) => { CONFIG.renderDays = parseInt(e.target.value); generateParticles(); };
        document.getElementById('in-res').onchange = (e) => { 
            CONFIG.resolution = parseInt(e.target.value); 
            document.getElementById('loader').style.display='flex'; 
            document.getElementById('loader').style.opacity=1;
            setTimeout(generateParticles, 100); 
        };

        function animate() {
            requestAnimationFrame(animate);
            const now = new Date();
            const nowSec = (now - CONFIG.baseDate) / 1000;
            const p = getPointForTime(nowSec);
            nowMarker.position.set(p.x, p.y, p.z);
            
            document.getElementById('live-clock').innerText = now.toLocaleTimeString('uk');
            controls.update(); renderer.render(scene, camera);
        }

        // START
        generateParticles();
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
