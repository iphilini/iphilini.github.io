<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HELIX: VISUAL CLARITY</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: #0a0e14; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(255,255,255,0.9); padding: 20px; border-radius: 12px; color: #1a202c; box-shadow: 0 10px 20px rgba(0,0,0,0.5); width: 300px; }
        .label { position: absolute; color: white; background: rgba(0,0,0,0.5); padding: 2px 5px; border-radius: 4px; font-size: 12px; pointer-events: none; }
        input { width: 100%; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <b style="color: #2b6cb0;">HELIX CHRONOS v0.1</b><br>
        <small>MODE: KNOWLEDGE SCANNER</small>
        <hr>
        <label>ЧАС (Timeline Pos):</label>
        <input id="time-slider" type="range" min="0" max="2.5" step="0.001" value="0.5">
        <div id="status" style="margin-top: 10px; font-size: 14px; font-weight: bold;"></div>
    </div>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); // Глибокий синій замість чорного

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- ДОДАЄМО СВІТЛО ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
        scene.add(pointLight);

        const helixGroup = new THREE.Group();
        scene.add(helixGroup);

        // Якір "ЗАРАЗ"
        const anchor = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xff0044, emissive: 0xff0044, emissiveIntensity: 0.5 })
        );
        scene.add(anchor);

        // SDN Вузли (Знання)
        const sdnData = [
            { t: 0.4, label: "РАНОК: ПЛАНУВАННЯ" },
            { t: 0.85, label: "ФОКУС: РОБОТА" },
            { t: 1.2, label: "ОБІД: ВІДПОЧИНОК" },
            { t: 1.9, label: "АНАЛІТИКА" },
            { t: 2.3, label: "ПІДСУМКИ ДНЯ" }
        ];

        const nodes = sdnData.map(data => {
            const node = new THREE.Mesh(
                new THREE.IcosahedronGeometry(0.6, 1),
                new THREE.MeshStandardMaterial({ color: 0xffcc00, wireframe: false, metalness: 0.8, roughness: 0.2 })
            );
            node.userData = data;
            scene.add(node);
            return node;
        });

        function getPos(t) {
            let x = Math.cos(t * Math.PI * 2) * 15;
            let z = Math.sin(t * Math.PI * 2) * 15;
            let y = t * 20;
            return new THREE.Vector3(x, y, z);
        }

        // Спіраль
        const points = [];
        for (let t = 0; t < 2.5; t += 0.01) points.push(getPos(t));
        const line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(points),
            new THREE.LineBasicMaterial({ color: 0x63b3ed, transparent: true, opacity: 0.3 })
        );
        helixGroup.add(line);

        // Позиціонування вузлів
        nodes.forEach(node => node.position.copy(getPos(node.userData.t)));

        function update() {
            const t = parseFloat(document.getElementById('time-slider').value);
            const pos = getPos(t);
            anchor.position.copy(pos);
            pointLight.position.copy(pos);

            // Оновлення статусу
            const currentTask = sdnData.find(d => Math.abs(d.t - t) < 0.1);
            document.getElementById('status').innerText = currentTask ? "ПОДІЯ: " + currentTask.label : "ПОШУК КОНТЕКСТУ...";
            document.getElementById('status').style.color = currentTask ? "#e53e3e" : "#2b6cb0";

            camera.position.lerp(new THREE.Vector3(pos.x + 30, pos.y + 20, pos.z + 30), 0.05);
            camera.lookAt(pos);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            nodes.forEach(n => n.rotation.y += 0.01);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
