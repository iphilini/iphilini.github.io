<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HELIX: DATA KERNEL</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: #00050a; overflow: hidden; font-family: 'Courier New', monospace; }
        #hud { position: absolute; top: 20px; left: 20px; color: #00ffff; background: rgba(0,20,40,0.9); padding: 15px; border: 2px solid #00ffff; border-radius: 8px; width: 300px; z-index: 100; }
        #clock { font-size: 24px; color: #ffcc00; margin-bottom: 10px; }
        #binary { position: absolute; bottom: 20px; right: 20px; color: #00ff00; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #00ff00; }
        .label { position: absolute; color: #000; background: #ffcc00; font-size: 14px; font-weight: bold; padding: 4px 10px; border-radius: 4px; pointer-events: none; box-shadow: 0 0 15px #ffcc00; }
        .input-group { margin-top: 10px; border-top: 1px dashed #00ffff; padding-top: 10px; }
        input { background: #000; border: 1px solid #00ffff; color: #00ffff; padding: 5px; width: 90%; margin-bottom: 5px; }
        button { background: #ffcc00; border: none; padding: 5px 10px; cursor: pointer; font-weight: bold; width: 100%; }
        button:hover { background: #fff; }
    </style>
</head>
<body>
    <div id="hud">
        <strong>HELIX_OS_KERNEL_v2.5</strong>
        <div id="clock">00:00:00</div>
        <div class="input-group">
            <input id="task-name" type="text" placeholder="НАЗВА ПОДІЇ...">
            <input id="task-time" type="time">
            <button onclick="addTask()">+ ДОДАТИ НА СПІРАЛЬ</button>
        </div>
        <button style="margin-top:10px; background:#00ffff;" onclick="isManual = !isManual">MODE: LIVE/MANUAL</button>
    </div>
    <div id="binary">000000000000</div>
    <div id="label-container"></div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x404040, 2.5));
        const pointLight = new THREE.PointLight(0x00ffff, 4, 100);
        scene.add(pointLight);

        let isManual = false;
        let timelinePos = 0;
        let tasks = JSON.parse(localStorage.getItem('helix_tasks')) || [];

        function getPos(t) {
            return new THREE.Vector3(Math.cos(t * Math.PI * 2) * 18, t * 25, Math.sin(t * Math.PI * 2) * 18);
        }

        // Спіраль
        const curvePoints = [];
        for(let t=0; t<3; t+=0.02) curvePoints.push(getPos(t));
        const tube = new THREE.Mesh(
            new THREE.TubeGeometry(new THREE.CatmullRomCurve3(curvePoints), 120, 0.15, 8, false),
            new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0.4 })
        );
        scene.add(tube);

        const anchor = new THREE.Mesh(new THREE.SphereGeometry(1.4, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0044, emissive: 0xff0044, emissiveIntensity: 2}));
        scene.add(anchor);

        let nodes = [];

        function renderTasks() {
            nodes.forEach(n => { scene.remove(n.mesh); n.div.remove(); });
            nodes = [];
            tasks.forEach(task => {
                const [h, m] = task.time.split(':').map(Number);
                const t = (h + m/60) / 24 * 3;
                
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshStandardMaterial({color: 0xffcc00, emissive: 0xffcc00}));
                mesh.position.copy(getPos(t));
                scene.add(mesh);

                const div = document.createElement('div');
                div.className = 'label';
                div.innerHTML = `[${task.time}] ${task.name}`;
                document.getElementById('label-container').appendChild(div);
                nodes.push({ mesh, div, t });
            });
        }

        function addTask() {
            const name = document.getElementById('task-name').value;
            const time = document.getElementById('task-time').value;
            if(!name || !time) return;
            tasks.push({ name, time });
            localStorage.setItem('helix_tasks', JSON.stringify(tasks));
            renderTasks();
            document.getElementById('task-name').value = '';
        }

        window.addEventListener('wheel', (e) => {
            if(!isManual) return;
            timelinePos += e.deltaY * 0.0004;
            timelinePos = Math.max(0, Math.min(2.9, timelinePos));
        });

        function update() {
            const now = new Date();
            if (!isManual) {
                const h = now.getHours() + now.getMinutes()/60 + now.getSeconds()/3600;
                timelinePos = (h / 24) * 3;
            }
            document.getElementById('clock').innerText = now.toTimeString().split(' ')[0];
            const pos = getPos(timelinePos);
            anchor.position.copy(pos);
            pointLight.position.copy(pos);
            document.getElementById('binary').innerText = Math.floor(timelinePos * 1024).toString(2).padStart(12, '0');

            nodes.forEach(n => {
                const screenPos = n.mesh.position.clone().project(camera);
                n.div.style.left = `${(screenPos.x + 1) * window.innerWidth / 2}px`;
                n.div.style.top = `${(-screenPos.y + 1) * window.innerHeight / 2}px`;
                const dist = pos.distanceTo(n.mesh.position);
                n.div.style.opacity = dist < 20 ? 1 : 0;
            });
            camera.position.lerp(new THREE.Vector3(pos.x + 40, pos.y + 15, pos.z + 40), 0.05);
            camera.lookAt(pos);
        }

        renderTasks();
        function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
