<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HELIX: KNOWLEDGE BEAMS ACTIVE</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: #010409; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(0,255,255,0.1); padding: 20px; border: 1px solid #00ffff; color: #fff; text-shadow: 0 0 5px #00ffff; }
        #binary-hud { position: absolute; bottom: 20px; right: 20px; color: #00ff00; font-size: 18px; text-align: right; opacity: 0.7; }
        input { width: 300px; }
    </style>
</head>
<body>
    <div id="ui">
        > PHASE_3: SLM_CONTEXT_ACTIVE<br>
        > KNOWLEDGE_LEVEL: <span id="k-level">INDIVIDUAL</span><br>
        > SCAN_RADIUS: <input id="time-slider" type="range" min="0" max="2.5" step="0.001" value="0.5">
    </div>
    <div id="binary-hud">INIT...</div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const helixGroup = new THREE.Group();
        scene.add(helixGroup);

        // Якір SLM
        const anchor = new THREE.Mesh(
            new THREE.SphereGeometry(0.7, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xff0044 })
        );
        scene.add(anchor);

        // Промені зв'язку (Beams)
        const beamGeometry = new THREE.BufferGeometry();
        const beamMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
        const beamLine = new THREE.LineSegments(beamGeometry, beamMaterial);
        scene.add(beamLine);

        function getPos(t) {
            let x = Math.cos(t * Math.PI * 2) * 12;
            let z = Math.sin(t * Math.PI * 2) * 12;
            let y = t * 15;
            x += Math.cos(t * Math.PI * 48) * 1.5;
            z += Math.sin(t * Math.PI * 48) * 1.5;
            return new THREE.Vector3(x, y, z);
        }

        // SDN Вузли як Knowledge Containers (HSM)
        const sdnPositions = [0.4, 0.85, 1.2, 1.9, 2.3];
        const nodes = sdnPositions.map(t => {
            const node = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: true })
            );
            node.position.copy(getPos(t));
            scene.add(node);
            return node;
        });

        // Основна спіраль
        const points = [];
        for (let t = 0; t < 2.5; t += 0.005) points.push(getPos(t));
        helixGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0x00d2ff, opacity: 0.1, transparent: true })));

        function update(time) {
            const t = parseFloat(document.getElementById('time-slider').value);
            const pos = getPos(t);
            anchor.position.copy(pos);

            // Бінарний код
            const word = (Math.floor(t * 1024)).toString(2).padStart(12, '0');
            document.getElementById('binary-hud').innerText = "ADDR: " + word;

            // Рівні знань HSM
            const kLevels = ["TACIT", "EXPLICIT", "INTEGRATED", "STRATEGIC"];
            document.getElementById('k-level').innerText = kLevels[Math.floor(t * 1.5)];

            // Малювання променів до вузлів (Context Beams)
            const beamPoints = [];
            nodes.forEach(node => {
                const dist = pos.distanceTo(node.position);
                if (dist < 15) { // Радіус видимості контексту
                    beamPoints.push(pos.x, pos.y, pos.z);
                    beamPoints.push(node.position.x, node.position.y, node.position.z);
                    node.rotation.y += 0.05;
                }
            });
            beamGeometry.setAttribute('position', new THREE.Float32BufferAttribute(beamPoints, 3));

            camera.position.lerp(new THREE.Vector3(pos.x + 25, pos.y + 15, pos.z + 25), 0.05);
            camera.lookAt(pos);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            update(time);
            renderer.render(scene, camera);
        }
        animate(0);
    </script>
</body>
</html>
