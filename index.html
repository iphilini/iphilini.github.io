<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HELIX: BIO-FEEDBACK</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: #00050a; overflow: hidden; font-family: 'Courier New', monospace; color: #00ffff; }
        #hud { position: absolute; top: 20px; left: 20px; background: rgba(0,20,40,0.95); padding: 15px; border: 2px solid #00ffff; border-radius: 8px; width: 330px; z-index: 100; box-shadow: 0 0 30px rgba(0,255,255,0.2); max-height: 85vh; overflow-y: auto; }
        .clock-label { font-size: 10px; color: #00aaaa; letter-spacing: 2px; }
        #real-clock { font-size: 24px; color: #ffffff; margin-bottom: 5px; }
        #virtual-clock { font-size: 32px; color: #ffcc00; text-shadow: 0 0 15px #ffcc00; }
        
        .task-item { background: rgba(0,255,255,0.05); margin: 5px 0; padding: 10px; border-left: 4px solid #444; font-size: 12px; transition: all 0.3s; cursor: pointer; }
        .task-item:hover { background: rgba(0,255,255,0.2); }
        .task-done { border-left-color: #00ff88 !important; opacity: 0.6; }
        .task-active { border-left-color: #00ffff !important; background: rgba(0,255,255,0.3); box-shadow: inset 0 0 10px #00ffff; }
        
        .controls { border-top: 1px solid #00ffff; margin-top: 10px; padding-top: 10px; }
        input { background: #000; border: 1px solid #333; color: #00ffff; padding: 8px; width: 90%; margin-bottom: 5px; }
        button { background: #00ffff; color: #000; border: none; padding: 8px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 5px; }
        
        .label { position: absolute; pointer-events: none; padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 13px; transform: translate(-50%, -50%); transition: all 0.5s; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="mode-tag" style="float:right; font-size:10px; padding:2px 5px; background:#ff0044; color:#fff;">LIVE</div>
        <strong>HELIX_CORE_v5.0</strong>
        
        <div style="margin: 15px 0;">
            <div class="clock-label">REAL_TIME</div>
            <div id="real-clock">00:00:00</div>
            <div class="clock-label">VIRTUAL_FOCUS</div>
            <div id="virtual-clock">00:00:00</div>
        </div>
        
        <div class="controls">
            <input id="task-name" type="text" placeholder="NEW_OBJECTIVE...">
            <input id="task-time" type="time">
            <button onclick="addTask()">INTEGRATE_TO_HELIX</button>
        </div>

        <div id="task-list-ui" style="margin-top:15px;"></div>
        <button style="background:none; color:#00ffff; border:1px solid #00ffff;" onclick="toggleMode()">TOGGLE_MANUAL_FOCUS</button>
    </div>
    <div id="label-container"></div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.3));
        const pointLight = new THREE.PointLight(0x00ffff, 5, 120);
        scene.add(pointLight);
        scene.add(new THREE.GridHelper(200, 50, 0x001122, 0x001122));

        let isManual = false;
        let timelinePos = 0;
        let tasks = JSON.parse(localStorage.getItem('helix_tasks_v5')) || [];

        function getPos(t) {
            return new THREE.Vector3(Math.cos(t * Math.PI * 2) * 20, t * 25, Math.sin(t * Math.PI * 2) * 20);
        }

        // Спіраль
        const curvePoints = [];
        for(let t=0; t<3.1; t+=0.02) curvePoints.push(getPos(t));
        const tube = new THREE.Mesh(
            new THREE.TubeGeometry(new THREE.CatmullRomCurve3(curvePoints), 160, 0.08, 8, false),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15 })
        );
        scene.add(tube);

        const anchor = new THREE.Mesh(new THREE.SphereGeometry(1.6, 32, 32), new THREE.MeshPhongMaterial({color: 0xff0044, emissive: 0xff0044, emissiveIntensity: 2}));
        scene.add(anchor);

        let nodes = [];

        function renderTasks() {
            nodes.forEach(n => { scene.remove(n.mesh); n.div.remove(); });
            nodes = [];
            const listUI = document.getElementById('task-list-ui');
            listUI.innerHTML = '';

            tasks.sort((a,b) => a.time.localeCompare(b.time)).forEach((task, index) => {
                const [h, m] = task.time.split(':').map(Number);
                const t = (h + m/60) / 24 * 3;
                const pos = getPos(t);

                // Визначення кольору стану
                let nodeColor = 0xffcc00; // Pending
                if (task.done) nodeColor = 0x00ff88; // Done

                const mesh = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(1.3, 1), 
                    new THREE.MeshStandardMaterial({color: nodeColor, emissive: nodeColor, emissiveIntensity: 0.5})
                );
                mesh.position.copy(pos);
                scene.add(mesh);

                const div = document.createElement('div');
                div.className = 'label';
                div.style.background = task.done ? '#00ff88' : '#ffcc00';
                div.style.color = '#000';
                div.innerHTML = task.name;
                document.getElementById('label-container').appendChild(div);

                const item = document.createElement('div');
                item.className = `task-item ${task.done ? 'task-done' : ''}`;
                item.innerHTML = `<b>${task.time}</b> ${task.name}`;
                item.onclick = () => focusTask(index);
                item.oncontextmenu = (e) => { e.preventDefault(); toggleDone(index); };
                listUI.appendChild(item);

                nodes.push({ mesh, div, t, id: index });
            });
            localStorage.setItem('helix_tasks_v5', JSON.stringify(tasks));
        }

        function addTask() {
            const name = document.getElementById('task-name').value;
            const time = document.getElementById('task-time').value;
            if(!name || !time) return;
            tasks.push({ name, time, done: false });
            renderTasks();
            document.getElementById('task-name').value = '';
        }

        function toggleDone(index) {
            tasks[index].done = !tasks[index].done;
            renderTasks();
        }

        function focusTask(index) {
            isManual = true;
            document.getElementById('mode-tag').innerText = "MANUAL";
            document.getElementById('mode-tag').style.background = "#00ffff";
            timelinePos = nodes.find(n => n.id === index).t;
        }

        function toggleMode() {
            isManual = !isManual;
            document.getElementById('mode-tag').innerText = isManual ? "MANUAL" : "LIVE";
            document.getElementById('mode-tag').style.background = isManual ? "#00ffff" : "#ff0044";
        }

        window.addEventListener('wheel', (e) => {
            if(!isManual) return;
            timelinePos = (timelinePos + e.deltaY * 0.0005 + 3) % 3;
        });

        function update() {
            const now = new Date();
            document.getElementById('real-clock').innerText = now.toTimeString().split(' ')[0];
            if (!isManual) {
                const h = now.getHours() + now.getMinutes()/60 + now.getSeconds()/3600;
                timelinePos = (h / 24) * 3;
            }
            
            const vTime = (timelinePos / 3) * 24;
            const vH = Math.floor(vTime);
            const vM = Math.floor((vTime - vH) * 60);
            document.getElementById('virtual-clock').innerText = `${vH.toString().padStart(2,'0')}:${vM.toString().padStart(2,'0')}:00`;

            const pos = getPos(timelinePos);
            anchor.position.copy(pos);
            pointLight.position.copy(pos);

            nodes.forEach(n => {
                const screenPos = n.mesh.position.clone().project(camera);
                n.div.style.left = `${(screenPos.x + 1) * window.innerWidth / 2}px`;
                n.div.style.top = `${(-screenPos.y + 1) * window.innerHeight / 2}px`;
                const d = pos.distanceTo(n.mesh.position);
                n.div.style.opacity = d < 25 ? (1 - d/25) : 0;
                n.mesh.rotation.y += 0.02;
            });
            camera.position.lerp(new THREE.Vector3(pos.x + 45, pos.y + 15, pos.z + 45), 0.05);
            camera.lookAt(pos);
        }

        renderTasks();
        function animate() { requestAnimationFrame(animate); update(); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
