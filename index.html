<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HELIX CORE: BINARY STEPS</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background-color: #050a10; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(0,255,255,0.05); padding: 20px; border: 1px dashed #00ffff; color: #00ffff; }
        input { width: 250px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui">
        > HELIX_OS INITIALIZED<br>
        > ADDR_MODE: SPIRAL_BINARY<br>
        > SCALE_STAGING: <input id="alpha-slider" type="range" min="0" max="2" step="0.01" value="1.0">
    </div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const grid = new THREE.GridHelper(100, 40, 0x002222, 0x001111);
        scene.add(grid);

        const helixGroup = new THREE.Group();
        scene.add(helixGroup);

        // Логіка Hamster World: кодування рівнів через кроки
        function getHelixPoint(t, alpha) {
            let x = 0, y = t * 15, z = 0;
            
            // S2: Денний ритм (Радіус 12)
            const dayRadius = 12 * Math.min(alpha, 1);
            x += Math.cos(t * Math.PI * 2) * dayRadius;
            z += Math.sin(t * Math.PI * 2) * dayRadius;

            // S1: Годинна сходинка (Радіус 2)
            // Активується лише коли Alpha > 1
            if (alpha > 1) {
                const hourAlpha = (alpha - 1);
                x += Math.cos(t * Math.PI * 48) * 3 * hourAlpha;
                z += Math.sin(t * Math.PI * 48) * 3 * hourAlpha;
            }
            return new THREE.Vector3(x, y, z);
        }

        function renderHelix() {
            helixGroup.clear();
            const alpha = parseFloat(document.getElementById('alpha-slider').value);
            
            // Створюємо "сходинки" (Points)
            const points = [];
            const colors = [];
            const color = new THREE.Color();

            for (let t = 0; t < 2.5; t += 0.005) {
                const p = getHelixPoint(t, alpha);
                points.push(p);

                // Кодування кольором за рівнем (Hamster World Logic)
                // Кожна "година" (t * 24) підсвічується яскравіше
                if ((t * 24) % 1 < 0.05) {
                    color.setHex(0xffffff); // Білий - маркер години
                } else {
                    color.setHSL(0.5, 1, 0.5 * (1 - t/3)); // Блакитний градієнт
                }
                colors.push(color.r, color.g, color.b);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                vertexColors: true, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            const line = new THREE.Line(geometry, material);
            helixGroup.add(line);
        }

        camera.position.set(35, 35, 35);
        camera.lookAt(0, 15, 0);

        document.getElementById('alpha-slider').oninput = renderHelix;
        renderHelix();

        function animate() {
            requestAnimationFrame(animate);
            helixGroup.rotation.y += 0.003;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
